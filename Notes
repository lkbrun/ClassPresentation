3. Authorize after you authenticate
	- Important to identify a person, but also to determine what actions this user can execute.
	- Authenticate may not be sufficient before deciding whether to disallow or allow some functionality of the system.
	- ATM: User cannot withdraw the whole account, authorized to withdraw a certain limit of cash.
	- Should be conducted after authenticate. Depends on privileges associated with the user, context of the request, time of the request, and the location of the requesting user.
	- Quitting job or promotions and user athorization must be changed.
	- Authorization may lead to authentication -> Say a user looses a device or walks away from it. Then it would be smart to have certain operations reauthenticate
	- Always authenticate users through back end(common infrastructure).

5. Define an approach that ensures all data are explicitly validated.
	- Systems and components often makes assumptions about data they operate on. It is important to explicitly ensure that such assumptions hold: Vulnerabilities frequently arise when implicit assumptions is done about data, which can be exploited by an attacker.
	- Design software to ensure that comprehensive data validation actually takes place and that all assumpiotns about data has been validated when they are used.
	- Design software to make it feasble to for a security reviewer to efficiently reason about and verify the correctness of data validation.
	- Designing for verifiability should take into account that code evolves, resulting in a risk of be vulnerable in a later stage in the development cycle. 
	- Design and use centralized validation mechanisms to ensure that all data entering a system is properly validated
		- Intercept all incoming requests, and apply basic input validation to all request parameters.
		- Centrally validate all fields of all received protocol messages before any actual processing takes place.
		- When consuming complex data formats must such parsers and validators be designed to robustly cope with potentially malicious or malformed inputs.
	- Transform data into canonical form before validation. 
	- Use common libraries of validation primitives. Email addresses, dates, etc. Should be White listing.
	- Use implementation language level types to capture assumptions about data validity. string representation of a date to a Date object. Downstream components are then free for checking syntax and can focus on checking pre conditions that are not supportet by the type's contract. 
	- Various problems arise from failure to address this security design principle
		- Injection vulnerabilities
		- XXS 
		- Attempting to validate data that is not in canonical form can allow validation to be bypassed. 
		- Non garbage collection language are exposed to memory corruption vulnerabilities such as buffer overflow, etc
		- Need upperbound on data size of input -> resource exhaustion
		- 

7. Identify sensitive data and how they should be handeled.
	- First tasks of developers: Identify sensitive data and how to protect it.
	- Over the years have many systems failed to protect.
	- Reason being either: failed to identify it as sensitive or failed to identify all the ways in which data could be manipulated.
	- Data sensitivity is context-sensitive:
		- Regulations
		- Company policies
		- constractual obligations
		- user expectations
	- Important to factor all relevant considerations into the design of a data sensitivity policy.
		- Different regulation systems: EU Data Protection Directive differ from the US
	- Not all data protection requirements are the same:
		- 1: For some data: confidentiality is critical: financial records and corporate intellectual property
		- 2: For some data: availability is critical: medial records
		- 3: For some data: integrity is critical: spoofing or substituting data to cause a system to misbehave intentionally
	- Access control mechanisms and cryptography for 1 and 3
	- Backups to preserve data availability

	- Data sets do not only exists at rest, but in transit between components within aP single system and between organizations.
	- Data between systems corssing trust boundaries.
	- Essential to identify trust boundaries and rectifying them with data protection policies is an essential design activity.
	- Trust is just as tricky as sensitive data.
	- Policy requirements and data sensitivity can change over time as business climate evolves, more interconnected systems
	- Regualtory revisiting and revising data protection plicies and their design implications is essential. 

9. Understand how integrating external components changes your attack surface
	- Unlikely to develope new system without external pieces of software.
	- Adding functionality, developerse often make use of existing components.
	- External components are "not written here" in the firm
		- off the shelf components, platforms, applications
		- Third party open source libraries
		- Widgets or gadgets added or loaded as part of a web project
		- Access to some functionality provided by the component that you plan to take advantage of( web service )
		- Software developed by different team within same organisation. 
	- These may be included as binaries, libraries, source code or as simple API's
	
	- Functionality should be acheived by reuse of tried and true pieces rather than creating from scratch.
	- Old components have been tested and validated and stand up to the company current secuirty standards.
	- By using rather than building: means the software inherits the security weaknesses, limitations, maintanance responsibility and threat model.
	- This must be solved, mitigated or accounted for when the system is finished.
	- Allocate time in software development methodology to consider security impact on your system when including external source
		- Changes the threat model ?
		- Add attack surface? 
		- Unused features?
		- Does the included components include other comps?
		- Source known and trusted? 
		- Documentation?
	- External components should not be trusted until appropriate secure controls have been applied.
	- At a minimum consider the following;
		- Isolate external components.	
		- Only enable functionality you intend to use
		- And if you include non used func you need to consider how that changes the attack surface.
		- If you cant configure security properties, use another library.
		- Or cannot satisfy desired security goals
		- Follow or track sources that track or publish security-related information.
		- Maintain an up to date list of all consumed exernal components
		- Authenticate data flow between system and external components.
		- Consider all data from external sources as tainted until proven valid.
		- Design for flexibility. If need of change, or component is to risky to use. Should be easy to change. 
		-  